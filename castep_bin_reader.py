"""
Reader module for CASTEP pdos_bin

Written based on the example `pdos_bin.f90` file in open-source OptaDos code
"""
import numpy as np
from scipy.io import FortranFile
from pymatgen.electronic_structure.core import Orbital, Spin


def read_pdos_bin(filename, endian='big'):
    """
    Read the pdos_bin file generated by CASTEP Spectral task.

    :returns: A dictionary of the data that have been read.
      the weights of each orbital in stored in the 'pdos_weights' array
      with dimension (n_orbital, n_max_eign, n_kpoints, n_spin)
    """
    esymbol = '>' if endian.upper() == 'BIG' else '>'
    dint = np.dtype(esymbol + 'i4')
    ddouble = np.dtype(esymbol + 'f8')
    dch80 = np.dtype(esymbol + 'a80')
    diarray = lambda x: '{}({},)i4'.format(esymbol, x)
    ddarray = lambda x: '{}({},)f8'.format(esymbol, x)

    with FortranFile(filename, header_dtype=np.dtype('>u4')) as fhandle:
        fversion = fhandle.read_record(ddouble)[0]
        fheader = fhandle.read_record(dch80)[0].decode()
        num_kpoints = fhandle.read_record(dint)[0]
        num_spins = fhandle.read_record(dint)[0]
        num_popn_orb = fhandle.read_record(dint)[0]
        max_eignenv = fhandle.read_record(dint)[0]

        # Now we start to read more data
        species = fhandle.read_record(diarray(num_popn_orb))
        ion = fhandle.read_record(diarray(num_popn_orb))
        am_channel = fhandle.read_record(diarray(num_popn_orb))

        # Now we initialize the storage space for the weights
        pdos_weights = np.zeros(
            (num_popn_orb, max_eignenv, num_kpoints, num_spins),
            dtype=np.float)

        kpoint_positions = np.zeros((num_kpoints, 3), dtype=np.float)
        num_eigenvalues = np.zeros(num_spins, dtype=np.int)
        # Now we start to read lots of read numbers
        for nk in range(num_kpoints):
            _, kpoint_positions[nk, :] = fhandle.read_record('>i4', '>(3,)f8')
            for ns in range(num_spins):
                _ = fhandle.read_record(dint)
                num_eigenvalues[ns] = fhandle.read_record(dint)
                for nb in range(num_eigenvalues[ns]):
                    pdos_weights[:, nb, nk, ns] = fhandle.read_record(
                        '>({},)f8'.format(num_popn_orb))

    output = {
        'fversion': fversion,
        'fheader': fheader,
        'num_kpoints': num_kpoints,
        'num_spins': num_spins,
        'num_popn_orb': num_popn_orb,
        'max_eigenenv': max_eignenv,
        'species': species,
        'ion': ion,
        'am_channel': am_channel,
        'pdos_weights': pdos_weights,
        'kpoints_positions': kpoint_positions,
        'num_eigenvalues': num_eigenvalues,
        'pdos_weights': pdos_weights,
    }
    return output


# Note that s-p labels are inferreed from dot castep output
# f labels - I know the first three is among the first three. 
# There is no way to tell if they are correct, f_1 is not very informative from VASP....
orbital_mapping = [
    [Orbital.s],
    [Orbital.px, Orbital.py, Orbital.pz],
    [Orbital.dz2, Orbital.dyz, Orbital.dxz, Orbital.dx2, Orbital.dxy],
    [Orbital.f_1, Orbital.f_2, Orbital.f_3, Orbital.f0, Orbital.f1, Orbital.f2, Orbital.f3]
]

def order_pdos_data(input_items):
    """
    Arrange the PDOS weights so it is more meaningful

    The result can be used to compute PDOS for creating CompleteDos object
    that can be used for Pymatgen

    :returns: A dictionary of {Site_index: {Orbital: {Spin: weight}}}
    """

    # We take average of each kpoints from here
    # One might task why not take account the kpoints weight?
    # because it should be taken account of in the TDOS
    weights = input_items['pdos_weights']
    # Specie index for all orbitals
    species = input_items['species']
    # Index of each ion for all orbitals
    ion = input_items['ion']
    num_spins = input_items['num_spins']
    # Angular momentum channel all orbitals
    am_channel = input_items['am_channel']

    unique_speices = np.unique(species)
    unique_speices.sort()
    site_index = 0
    output_data = {}
    # Initialise storage space
    for specie in unique_speices:
        specie_mask = specie == species
        # Total number of ions for this specie
        total_ions = ion[specie_mask].max()
        # Note that indice are from one, not zero
        for nion in range(1, total_ions + 1):
            # Iterate through each ion
            ion_mask =  (ion == nion) & specie_mask
            max_am = am_channel[ion_mask].max()
            site_dict = {}  # {Orbital: {Spin: weight}...}
            for am in range(max_am + 1):
                # Collect the angular momentum channels
                ion_am_mask = (am_channel == am) & ion_mask
                # Indices of each matched channels
                ion_am_idx = np.where(ion_am_mask)[0]
                for iam, iloc in enumerate(ion_am_idx):
                    # iloc - index of the oribtal
                    # You can have 4 orbitals for p channel - they have difference n numbers
                    this_orb = orbital_mapping[am][iam % (2 * am + 1)]
                    orb_dict = {}  # {Spin: weight...}
                    if num_spins == 2:
                        for ispin, espin in enumerate((Spin.up, Spin.down)):
                            # Sumup 
                            wtmp  = weights[iloc, :, :, ispin]
                            orb_dict[espin] = wtmp
                    else:
                        orb_dict[Spin.up] = weights[iloc, :, :, 0]

                    # Now we have the orb_dict populated
                    if this_orb is orb_dict:
                        site_dict[this_orb] = merge_spin(site_dict[this_orb], orb_dict)
                    else:
                        site_dict[this_orb] = orb_dict
            # Now we populated site_dict add it to output_data
            output_data[site_index] = site_dict
            site_index += 1
    
    return output_data


def read_dos(bands_file, order_pdos_data, bin_width=0.01, gaussian=None,
              padding=None, emin=None, emax=None, efermi_to_vbm=True):
    """Convert DOS data from CASTEP .bands file to Pymatgen/Sumo format

    The data is binned into a regular series using np.histogram

    Args:
        bands_file (:obj:`str`): Path to CASTEP prefix.bands output file. The
            k-point positions, weights and eigenvalues are read from this file.
        bin_width (:obj:`float`, optional): Spacing for DOS energy axis
        gaussian (:obj:`float` or None, optional): Width of Gaussian broadening
            function
        padding (:obj:`float`, optional): Energy range above and below occupied
            region. (This is not used if xmin and xmax are set.)
        emin (:obj:`float`, optional): Minimum energy value for output DOS)
        emax (:obj:`float`, optional): Maximum energy value for output DOS
        efermi_to_vbm (:obj:`bool`, optional):
            If a bandgap is detected, modify the stored Fermi energy
            so that it lies at the VBM.

    Returns:
        :obj:`pymatgen.electronic_structure.dos.Dos`
    """
    from sumo.io.castep import _read_bands_header_verbose, read_bands_eigenvalues, _is_metal,_get_vbm, _ry_to_ev
    header = _read_bands_header_verbose(bands_file)

    logging.info("Reading band eigenvalues...")
    _, weights, eigenvalues = read_bands_eigenvalues(bands_file, header)

    calc_efermi = header['e_fermi'][0] * _ry_to_ev * 2
    if efermi_to_vbm and not _is_metal(eigenvalues, calc_efermi):
        logging.info("Setting energy zero to VBM")
        efermi = _get_vbm(eigenvalues, calc_efermi)
    else:
        logging.info("Setting energy zero to Fermi energy")
        efermi = calc_efermi

    emin_data = min(eigenvalues[Spin.up].flatten())
    emax_data = max(eigenvalues[Spin.up].flatten())
    if Spin.down in eigenvalues:
        emin_data = min(emin_data, min(eigenvalues[Spin.down].flatten()))
        emax_data = max(emax_data, max(eigenvalues[Spin.down].flatten()))

    if padding is None and gaussian:
        padding = gaussian * 3
    elif padding is None:
        padding = 0.5

    if emin is None:
        emin = emin_data - padding
    if emax is None:
        emax = emax_data + padding

    # Shift sampling window to account for zeroing at VBM/EFermi
    emin += efermi
    emax += efermi

    bins = np.arange(emin, emax + bin_width, bin_width)
    energies = (bins[1:] + bins[:-1]) / 2

    # Add rows to weights for each band so they are aligned with eigenval data
    weights = weights * np.ones([eigenvalues[Spin.up].shape[0], 1])

    dos_data = {spin: np.histogram(eigenvalue_set, bins=bins,
                                   weights=weights)[0]
                for spin, eigenvalue_set in eigenvalues.items()}
    # Compute pdos
    pdos_data = {}
    for site, orbs_dict in order_pdos_data.items():
        orbs_outdict = {}
        for orb, spin_dict in orbs_dict.items():
            pdos_orbit = {spin: np.histogram(eigenvalue_set, bins=bins,
                                   weights=weights * spin_dict[spin])[0]  # <--- Here  I need to weight it properly using the weights!!!!
                        for spin, eigenvalue_set in eigenvalues.items()}
            orbs_outdict[orb] = pdos_orbit
        pdos_data[site] = orbs_outdict
            
    dos = Dos(efermi, energies, dos_data)
    if gaussian:
        dos.densities = dos.get_smeared_densities(gaussian)

    return dos, pdos_data, eigenvalues

def merge_spin(spin_d1, spin_d2):
    """Merge two dictionary contenting the weights"""
    if len(spin_d1) != len(spin_d2):
        raise RuntimeError("Critical - mismatch spin-dict length")
    out = {}
    for spin in spin_d1:
        out[spin] = spin_d1[spin] + spin_d2[spin] 
    return out

                
            